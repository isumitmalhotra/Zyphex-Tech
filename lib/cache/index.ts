import { getRedisClient, cacheKeys, cacheTTL } from './redis'; import { memoryCacheAdapter, type CacheAdapter } from './memory';  // Cache manager that uses Redis with memory fallback class CacheManager {   private primaryCache: CacheAdapter | null = null;   private fallbackCache: CacheAdapter = memoryCacheAdapter;    async getCache(): Promise<CacheAdapter> {     // Try to use Redis first     const redis = getRedisClient();     if (redis && await this.isRedisHealthy()) {       return this.getRedisAdapter();     }          // Fallback to memory cache     return this.fallbackCache;   }    private async isRedisHealthy(): Promise<boolean> {     try {       const redis = getRedisClient();       if (!redis) return false;              await redis.ping();       return true;     } catch {       return false;     }   }    private getRedisAdapter(): CacheAdapter {     const redis = getRedisClient();     if (!redis) throw new Error('Redis client not available');      return {       async get<T>(key: string): Promise<T | null> {         try {           const result = await redis.get(key);           return result ? JSON.parse(result) : null;         } catch {           return null;         }       },        async set<T>(key: string, value: T, ttl: number = 300): Promise<boolean> {         try {           await redis.setex(key, ttl, JSON.stringify(value));           return true;         } catch {           return false;         }       },        async delete(key: string): Promise<boolean> {         try {           await redis.del(key);           return true;         } catch {           return false;         }       },        async deletePattern(pattern: string): Promise<boolean> {         try {           const keys = await redis.keys(pattern);           if (keys.length > 0) {             await redis.del(...keys);           }           return true;         } catch {           return false;         }       },        async clear(): Promise<boolean> {         try {           await redis.flushdb();           return true;         } catch {           return false;         }       },        async isHealthy(): Promise<boolean> {         try {           await redis.ping();           return true;         } catch {           return false;         }       }     };   }    // High-level cache operations   async get<T>(key: string): Promise<T | null> {     const cache = await this.getCache();     return cache.get<T>(key);   }    async set<T>(key: string, value: T, ttl?: number): Promise<boolean> {     const cache = await this.getCache();     return cache.set(key, value, ttl);   }    async delete(key: string): Promise<boolean> {     // Try to delete from both caches     const cache = await this.getCache();     const primaryResult = await cache.delete(key);          // Also delete from fallback if we're using Redis     if (cache !== this.fallbackCache) {       await this.fallbackCache.delete(key);     }          return primaryResult;   }    async deletePattern(pattern: string): Promise<boolean> {     const cache = await this.getCache();     const primaryResult = await cache.deletePattern(pattern);          // Also delete from fallback if we're using Redis     if (cache !== this.fallbackCache) {       await this.fallbackCache.deletePattern(pattern);     }          return primaryResult;   }    async clear(): Promise<boolean> {     const cache = await this.getCache();     const primaryResult = await cache.clear();          // Also clear fallback     await this.fallbackCache.clear();          return primaryResult;   }    async getStatus(): Promise<{     primary: { type: 'redis' | 'memory'; healthy: boolean };     fallback: { type: 'memory'; healthy: boolean };   }> {     const redisHealthy = await this.isRedisHealthy();     const memoryHealthy = await this.fallbackCache.isHealthy();          return {       primary: {         type: redisHealthy ? 'redis' : 'memory',         healthy: redisHealthy || memoryHealthy       },       fallback: {         type: 'memory',         healthy: memoryHealthy       }     };   } }  // Singleton instance export const cacheManager = new CacheManager();  // Content-specific cache functions using the manager export async function cacheContentType(contentType: unknown): Promise<void> {   const key = cacheKeys.contentType((contentType as { id: string }).id);   await cacheManager.set(key, contentType, cacheTTL.contentType); }  export async function getCachedContentType(id: string): Promise<unknown | null> {   const key = cacheKeys.contentType(id);   return await cacheManager.get(key); }  export async function cacheContentTypes(contentTypes: unknown[]): Promise<void> {   const key = cacheKeys.contentTypes();   await cacheManager.set(key, contentTypes, cacheTTL.contentTypes); }  export async function getCachedContentTypes(): Promise<unknown[] | null> {   const key = cacheKeys.contentTypes();   return await cacheManager.get(key); }  export async function cacheDynamicContent(typeId: string, items: unknown[]): Promise<void> {   const key = cacheKeys.dynamicContent(typeId);   await cacheManager.set(key, items, cacheTTL.dynamicContent); }  export async function getCachedDynamicContent(typeId: string): Promise<unknown[] | null> {   const key = cacheKeys.dynamicContent(typeId);   return await cacheManager.get(key); }  export async function cacheDynamicContentItem(item: unknown): Promise<void> {   const key = cacheKeys.dynamicContentItem((item as { id: string }).id);   await cacheManager.set(key, item, cacheTTL.dynamicContent); }  export async function getCachedDynamicContentItem(id: string): Promise<unknown | null> {   const key = cacheKeys.dynamicContentItem(id);   return await cacheManager.get(key); }  // Cache invalidation functions export async function invalidateContentTypeCache(id?: string): Promise<void> {   if (id) {     await cacheManager.delete(cacheKeys.contentType(id));   }      // Always invalidate the list cache when any content type changes   await cacheManager.delete(cacheKeys.contentTypes()); }  export async function invalidateDynamicContentCache(typeId?: string, itemId?: string): Promise<void> {   if (typeId) {     await cacheManager.delete(cacheKeys.dynamicContent(typeId));   }      if (itemId) {     await cacheManager.delete(cacheKeys.dynamicContentItem(itemId));   } }  export async function invalidateAllContentCache(): Promise<void> {   await cacheManager.deletePattern('content*'); }  // Export cache manager for direct access export { cacheManager as cache };